<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>instance.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <li class="nav-link nav-home-link"><a href="index.html">Home</a></li><li class="nav-heading">Classes</li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="Condition.html">Condition</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Condition.html#process">process</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="Configuration.html">Configuration</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="GotoScope.html">GotoScope</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="GotoScope.html#process">process</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="IfAllCondition.html">IfAllCondition</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="IfAllCondition.html#match">match</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="IfAllCondition.html#process">process</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="IfExistCondition.html">IfExistCondition</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="IfExistCondition.html#match">match</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="IfExistCondition.html#process">process</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="IfOnlyExistCondition.html">IfOnlyExistCondition</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="IfOnlyExistCondition.html#match">match</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="IfOnlyExistCondition.html#process">process</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="Instance.html">Instance</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Instance.html#append">append</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Instance.html#callHelper">callHelper</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Instance.html#callHelperSync">callHelperSync</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Instance.html#delete">delete</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Instance.html#gotoNode">gotoNode</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Instance.html#insert">insert</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Instance.html#insertAfter">insertAfter</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Instance.html#insertBefore">insertBefore</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Instance.html#matchFilesInPathsSync">matchFilesInPathsSync</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Instance.html#noop">noop</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Instance.html#prepend">prepend</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Instance.html#processSync">processSync</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Instance.html#processWithNode">processWithNode</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Instance.html#processWithOtherNode">processWithOtherNode</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Instance.html#remove">remove</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Instance.html#replace">replace</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Instance.html#replaceWith">replaceWith</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Instance.html#testSync">testSync</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="NodeVersion.html">NodeVersion</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="NodeVersion.html#match">match</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="NodeVersion.html#matchSync">matchSync</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="NpmVersion.html">NpmVersion</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="NpmVersion.html#match">match</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="NpmVersion.html#matchSync">matchSync</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="Rewriter.html">Rewriter</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Rewriter.html#.clear">clear</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Rewriter.html#.fetch">fetch</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Rewriter.html#.register">register</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Rewriter.html#addAffectedFile">addAffectedFile</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Rewriter.html#addFile">addFile</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Rewriter.html#addFileSync">addFileSync</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Rewriter.html#addSnippet">addSnippet</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Rewriter.html#addSnippetSync">addSnippetSync</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Rewriter.html#configure">configure</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Rewriter.html#ifNode">ifNode</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Rewriter.html#ifNpm">ifNpm</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Rewriter.html#process">process</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Rewriter.html#processSync">processSync</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Rewriter.html#processWithSandbox">processWithSandbox</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Rewriter.html#processWithSandboxSync">processWithSandboxSync</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Rewriter.html#removeFile">removeFile</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Rewriter.html#removeFileSync">removeFileSync</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Rewriter.html#test">test</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Rewriter.html#testSync">testSync</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Rewriter.html#withinFile">withinFile</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Rewriter.html#withinFile">withinFile</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Rewriter.html#withinFiles">withinFiles</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Rewriter.html#withinFilesSync">withinFilesSync</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="Scope.html">Scope</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="UnlessExistCondition.html">UnlessExistCondition</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="UnlessExistCondition.html#match">match</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="UnlessExistCondition.html#process">process</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="WithinScope.html">WithinScope</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="WithinScope.html#process">process</a></span></li><li class="nav-heading"><a href="global.html">Globals</a></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#evalSnippet">evalSnippet</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#evalSnippetSync">evalSnippetSync</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#indent">indent</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#isValidFile">isValidFile</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#isValidFileSync">isValidFileSync</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#loadSnippet">loadSnippet</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#loadSnippetSync">loadSnippetSync</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#rewriteSnippetToAsyncVersion">rewriteSnippetToAsyncVersion</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#rewriteSnippetToSyncVersion">rewriteSnippetToSyncVersion</a></span></li>
</nav>

<div id="main">
    
    <h1 class="page-title">instance.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>"use strict";
var __createBinding = (this &amp;&amp; this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this &amp;&amp; this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this &amp;&amp; this.__importStar) || function (mod) {
    if (mod &amp;&amp; mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" &amp;&amp; Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this &amp;&amp; this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this &amp;&amp; this.__importDefault) || function (mod) {
    return (mod &amp;&amp; mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const typescript_1 = __importDefault(require("typescript"));
const fs_1 = __importStar(require("fs"));
const path_1 = __importDefault(require("path"));
const fast_glob_1 = __importDefault(require("fast-glob"));
const minimatch_1 = __importDefault(require("minimatch"));
const debug_1 = __importDefault(require("debug"));
const configuration_1 = __importDefault(require("./configuration"));
const scope_1 = require("./scope");
const condition_1 = require("./condition");
const utils_1 = require("./utils");
const node_query_1 = __importStar(require("@xinminlabs/node-query"));
const node_mutation_1 = __importStar(require("@xinminlabs/node-mutation"));
const espree_adapter_1 = __importDefault(require("./node-mutation/espree-adapter"));
const espree_adapter_2 = __importDefault(require("./node-query/espree-adapter"));
const options_1 = require("./types/options");
const espree = require("@xinminlabs/espree");
/**
 * Instance is an execution unit, it finds specified ast nodes,
 * checks if the nodes match some conditions, then insert, replace or delete code.
 * One instance can contains one or many Scope and Condition.
 * @borrows Instance#withinNode as Instance#withNode
 */
class Instance {
    /**
     * Create an Instance
     * @param {string} filePattern - pattern to find files, e.g. `lib/*.js`
     * @param {Function} func - a function to find nodes, match conditions and rewrite code.
     */
    constructor(rewriter, filePattern, func) {
        this.rewriter = rewriter;
        this.filePattern = filePattern;
        this.func = func;
        let strategy = node_mutation_1.Strategy.KEEP_RUNNING;
        if (rewriter.options.strategy === options_1.Strategy.ALLOW_INSERT_AT_SAME_POSITION) {
            strategy = strategy | node_mutation_1.Strategy.ALLOW_INSERT_AT_SAME_POSITION;
        }
        node_mutation_1.default.configure({ strategy });
    }
    /**
     * Process the instance.
     * It finds all files, for each file, it runs the func, rewrites the original code,
     * then write the code back to the original file.
     */
    processSync() {
        if ((0, utils_1.isValidFileSync)(configuration_1.default.rootPath) &amp;&amp;
            (0, minimatch_1.default)(configuration_1.default.rootPath, this.filePattern)) {
            return this.processFileSync(configuration_1.default.rootPath);
        }
        this.matchFilesInPathsSync().forEach((filePath) => this.processFileSync(filePath));
    }
    process() {
        return __awaiter(this, void 0, void 0, function* () {
            if ((yield (0, utils_1.isValidFile)(configuration_1.default.rootPath)) &amp;&amp;
                (0, minimatch_1.default)(configuration_1.default.rootPath, this.filePattern)) {
                return this.processFile(configuration_1.default.rootPath);
            }
            const filePaths = yield this.matchFilesInPaths();
            yield Promise.all(filePaths.map((filePath) => __awaiter(this, void 0, void 0, function* () { return yield this.processFile(filePath); })));
        });
    }
    /**
     * Test the instance.
     * It finds all files, for each file, it runs the func, and gets the process results.
     * @returns {TestResultExt[]} test results
     */
    testSync() {
        if ((0, utils_1.isValidFileSync)(configuration_1.default.rootPath) &amp;&amp;
            (0, minimatch_1.default)(configuration_1.default.rootPath, this.filePattern)) {
            return [this.testFileSync(configuration_1.default.rootPath)];
        }
        return this.matchFilesInPathsSync().map((filePath) => this.testFileSync(filePath));
    }
    test() {
        return __awaiter(this, void 0, void 0, function* () {
            if ((yield (0, utils_1.isValidFile)(configuration_1.default.rootPath)) &amp;&amp;
                (0, minimatch_1.default)(configuration_1.default.rootPath, this.filePattern)) {
                return yield Promise.resolve([
                    yield this.testFile(configuration_1.default.rootPath),
                ]);
            }
            const filePaths = yield this.matchFilesInPaths();
            return yield Promise.all(filePaths.map((filePath) => __awaiter(this, void 0, void 0, function* () { return yield this.testFile(filePath); })));
        });
    }
    /**
     * Set currentNode to node and process.
     * @param {Node} node - set to current node
     * @param {Function} func
     */
    processWithNode(node, func) {
        this.currentNode = node;
        func.call(this, this);
        this.currentNode = node;
    }
    /**
     * Set currentNode properly, process and set currentNode back to original currentNode.
     * @param {Node} node - set to other node
     * @param {Function} func
     */
    processWithOtherNode(node, func) {
        const originalNode = this.currentNode;
        this.currentNode = node;
        func.call(this, this);
        this.currentNode = originalNode;
    }
    withinNode(nqlOrRules, options, func) {
        if (typeof options === "function") {
            new scope_1.WithinScope(Instance.current, nqlOrRules, {}, options).process();
        }
        else {
            new scope_1.WithinScope(Instance.current, nqlOrRules, options, func).process();
        }
    }
    /**
     * Create a {@link GotoScope} to go to a child node,
     * then continue operating on the child node.
     * @example
     * // `$.ajax({ ... })` goes to `$.ajax`
     * gotoNode('callee')
     * @param {string} child_node_name - the name of the child nodes.
     * @param {Function} func - to continue operating on the matching nodes.
     */
    gotoNode(childNodeName, func) {
        new scope_1.GotoScope(Instance.current, childNodeName, func).process();
    }
    ifExistNode(nqlOrRules, options, func, elseFunc) {
        if (typeof options === "function") {
            return new condition_1.IfExistCondition(Instance.current, nqlOrRules, {}, options, func).process();
        }
        return new condition_1.IfExistCondition(Instance.current, nqlOrRules, options, func, elseFunc).process();
    }
    unlessExistNode(nqlOrRules, options, func, elseFunc) {
        if (typeof options === "function") {
            return new condition_1.UnlessExistCondition(Instance.current, nqlOrRules, {}, options, func).process();
        }
        return new condition_1.UnlessExistCondition(Instance.current, nqlOrRules, options, func, elseFunc).process();
    }
    ifOnlyExistNode(nqlOrRules, options, func, elseFunc) {
        if (typeof options === "function") {
            return new condition_1.IfOnlyExistCondition(Instance.current, nqlOrRules, {}, options, func).process();
        }
        return new condition_1.IfOnlyExistCondition(Instance.current, nqlOrRules, options, func, elseFunc).process();
    }
    ifAllNodes(nqlOrRules, options, func, elseFunc) {
        if (typeof options === "function") {
            return new condition_1.IfAllCondition(Instance.current, nqlOrRules, {}, options, func).process();
        }
        return new condition_1.IfAllCondition(Instance.current, nqlOrRules, options, func, elseFunc).process();
    }
    /**
     * Append the code to the bottom of current node body.
     * @example
     * // foo() => {}
     * // will be converted to
     * // foo() => {}
     * // bar() => {}
     * // after executing
     * withNode({ nodeType: "MethodDefinition", key: "foo" }, () => {
     *   append("bar() => {}")
     * })
     * @param {string} code - need to be appended.
     */
    append(code) {
        Instance.current.currentMutation.append(Instance.current.currentNode, code);
    }
    /**
     * Prepend the code to the top of current node body.
     * @example
     * // const foo = bar
     * // will be converted to
     * // 'use strict'
     * // const foo = bar
     * // after executing
     * prepend("'use strict'");
     * @param {string} code - need to be prepended.
     */
    prepend(code) {
        Instance.current.currentMutation.prepend(Instance.current.currentNode, code);
    }
    /**
     * Insert code to the beginning or end of the current node.
     * @example
     * // import React, { Component } from 'react'
     * // will be converted to
     * // import React, { Component, useState } from 'react'
     * // after executing
     * withNode({ nodeType: "ImportSpecifier", name: "Component" }, () => {
     *   insert(", useState", { at: "end" });
     * });
     * @param {string} code - code need to be inserted
     * @param {Object} options - insert position, beginning or end, end is the default
     */
    insert(code, options) {
        Instance.current.currentMutation.insert(Instance.current.currentNode, code, options);
    }
    /**
     * Insert the code next to the current node.
     * @example
     * // import React from 'react'
     * // will be converted to
     * // import React from 'react'
     * // import PropTypes from 'prop-types'
     * // after executing
     * withNode({ nodeType: "ImportClause", name: "React" }, () => {
     *   insertAfter("import PropTypes from 'prop-types'");
     * });
     * @param {string} code - code need to be inserted
     * @param {Object} options - insert options, default is `{ at: "end" }`
     */
    insertAfter(code, options) {
        const column = " ".repeat(node_mutation_1.default.getAdapter().getStartLoc(Instance.current.currentNode).column);
        Instance.current.currentMutation.insert(Instance.current.currentNode, `\n${column}${code}`, Object.assign(Object.assign({}, options), { at: "end" }));
    }
    /**
     * Insert the code previous to the current node.
     * @example
     * // import React from 'react'
     * // will be converted to
     * // import PropTypes from 'prop-types'
     * // import React from 'react'
     * // after executing
     * withNode({ nodeType: "ImportClause", name: "React" }, () => {
     *   insertBefore("import PropTypes from 'prop-types'");
     * });
     * @param {string} code - code need to be inserted
     * @param {Object} options - insert options, default is `{ at: "beginning" }`
     */
    insertBefore(code, options) {
        const column = " ".repeat(node_mutation_1.default.getAdapter().getStartLoc(Instance.current.currentNode).column);
        Instance.current.currentMutation.insert(Instance.current.currentNode, `${code}\n${column}`, Object.assign(Object.assign({}, options), { at: "beginning" }));
    }
    /**
     * Delete child nodes.
     * @example
     * // const someObject = { cat: cat, dog: dog, bird: bird }
     * // will be converted to
     * // const someObject = { cat, dog, bird }
     * // after executing
     * withNode({ nodeType: "Property", key: { nodeType: "Identifier" }, value: { nodeType: "Identifier" } }, () => {
     *   deleteNode(["semicolon", "value"]);
     * });
     * @param {string} selectors - name of child nodes
     */
    delete(selectors) {
        Instance.current.currentMutation.delete(Instance.current.currentNode, selectors);
    }
    /**
     * Remove current node.
     * @example
     * // class A {
     * //   constructor(props) {
     * //     super(props)
     * //   }
     * // }
     * // will be converted to
     * // class A {
     * // }
     * // after executing
     * withNode({ nodeType: "MethodDefinition", kind: "constructor" }, () => {
     *   remove();
     * });
     */
    remove() {
        Instance.current.currentMutation.remove(Instance.current.currentNode);
    }
    /**
     * Replace child nodes with code.
     * @example
     * // $form.submit();
     * // will be converted to
     * // $form.trigger('submit');
     * // after executing
     * withNode({ nodeType: "CallExpression", callee: { nodeType: "MemberExpression", object: /^\$/, property: 'submit' }, arguments: { length: 0 } }, () => {
     *   replace(["callee.property", "arguments"], { with: "trigger('submit')" });
     * });
     * @param {string|array} selectors - name of child nodes.
     * @param {Object} options - code need to be replaced with.
     */
    replace(selectors, options) {
        Instance.current.currentMutation.replace(Instance.current.currentNode, selectors, options);
    }
    /**
     * Replace current node with code.
     * @example
     * // module.exports = Rewriter
     * // will be converted to
     * // export default Rewriter
     * // after executing
     * withNode({ nodeType: "ExpressionStatement", expression: { nodeType: "AssignmentExpression", left: { nodeType: "MemberExpression", object: "module", property: "exports" }, right: { nodeType: "Identifier" } } }, () => {
     *   replaceWith("export default {{expression.right}}");
     * });
     * @param {string} code - code need to be replaced.
     * @param {Object} options - { autoIndent: true } if auto fix indent
     */
    replaceWith(code, options) {
        Instance.current.currentMutation.replaceWith(Instance.current.currentNode, code, options);
    }
    /**
     * No operation.
     */
    noop() {
        Instance.current.currentMutation.noop(Instance.current.currentNode);
    }
    /**
     * Sync to call a helper to run shared code.
     * @param {string} helperName - snippet helper name, it can be a http url, file path or a short name
     * @param options - options can be anything it needs to be passed to the helper
     */
    callHelperSync(helperName, options) {
        const helperContent = (0, utils_1.loadSnippetSync)(helperName);
        Instance.current.options = options;
        Function(helperContent).call(Instance.current, Instance.current);
        Instance.current.options = undefined;
    }
    /**
     * Async to call a helper to run shared code.
     * @async
     * @param {string} helperName - snippet helper name, it can be a http url, file path or a short name
     * @param options - options can be anything it needs to be passed to the helper
     */
    callHelper(helperName, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const helperContent = yield (0, utils_1.loadSnippet)(helperName);
            Instance.current.options = options;
            Function(helperContent).call(Instance.current, Instance.current);
            Instance.current.options = undefined;
        });
    }
    mutationAdapter() {
        return node_mutation_1.default.getAdapter();
    }
    /**
     * Process one file.
     * @private
     * @param {string} filePath - file path
     */
    processFileSync(filePath) {
        if (this.rewriter.options.parser === options_1.Parser.ESPREE &amp;&amp;
            [".ts", ".tsx"].includes(path_1.default.extname(filePath))) {
            return;
        }
        this.currentFilePath = path_1.default.join(configuration_1.default.rootPath, filePath);
        if (configuration_1.default.showRunProcess) {
            console.log(filePath);
        }
        while (true) {
            let source = fs_1.default.readFileSync(this.currentFilePath, "utf-8");
            this.currentFileSource = source;
            this.currentMutation = new node_mutation_1.default(source);
            try {
                const node = this.parseCode(this.currentFilePath, source);
                this.processWithNode(node, this.func);
                const result = this.currentMutation.process();
                (0, debug_1.default)("synvert-core:process")(result);
                if (result.affected) {
                    this.rewriter.addAffectedFile(filePath);
                    fs_1.default.writeFileSync(this.currentFilePath, result.newSource);
                }
                if (!result.conflicted) {
                    break;
                }
            }
            catch (e) {
                console.log(e);
                if (e instanceof SyntaxError) {
                    console.log(`May not parse source code: ${source}`);
                }
                break;
            }
        }
    }
    processFile(filePath) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.rewriter.options.parser === options_1.Parser.ESPREE &amp;&amp;
                [".ts", ".tsx"].includes(path_1.default.extname(filePath))) {
                return;
            }
            this.currentFilePath = path_1.default.join(configuration_1.default.rootPath, filePath);
            if (configuration_1.default.showRunProcess) {
                console.log(filePath);
            }
            while (true) {
                let source = yield fs_1.promises.readFile(this.currentFilePath, "utf-8");
                this.currentFileSource = source;
                this.currentMutation = new node_mutation_1.default(source);
                try {
                    const node = this.parseCode(this.currentFilePath, source);
                    this.processWithNode(node, this.func);
                    const result = this.currentMutation.process();
                    (0, debug_1.default)("synvert-core:process")(result);
                    if (result.affected) {
                        this.rewriter.addAffectedFile(filePath);
                        yield fs_1.promises.writeFile(this.currentFilePath, result.newSource);
                    }
                    if (!result.conflicted) {
                        break;
                    }
                }
                catch (e) {
                    console.log(e);
                    if (e instanceof SyntaxError) {
                        console.log(`May not parse source code: ${source}`);
                    }
                    break;
                }
            }
        });
    }
    /**
     * Test one file.
     * @private
     * @param {string} filePath - file path
     * @returns {TestResultExt}
     */
    testFileSync(filePath) {
        if (this.rewriter.options.parser === options_1.Parser.ESPREE &amp;&amp;
            [".ts", ".tsx"].includes(path_1.default.extname(filePath))) {
            return { conflicted: false, affected: false, actions: [], filePath };
        }
        this.currentFilePath = path_1.default.join(configuration_1.default.rootPath, filePath);
        let source = fs_1.default.readFileSync(this.currentFilePath, "utf-8");
        this.currentFileSource = source;
        this.currentMutation = new node_mutation_1.default(source);
        const node = this.parseCode(this.currentFilePath, source);
        this.processWithNode(node, this.func);
        const result = this.currentMutation.test();
        result.filePath = filePath;
        (0, debug_1.default)("synvert-core:test")(result);
        return result;
    }
    testFile(filePath) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.rewriter.options.parser === options_1.Parser.ESPREE &amp;&amp;
                [".ts", ".tsx"].includes(path_1.default.extname(filePath))) {
                return { conflicted: false, affected: false, actions: [], filePath };
            }
            this.currentFilePath = path_1.default.join(configuration_1.default.rootPath, filePath);
            let source = yield fs_1.promises.readFile(this.currentFilePath, "utf-8");
            this.currentFileSource = source;
            this.currentMutation = new node_mutation_1.default(source);
            const node = this.parseCode(this.currentFilePath, source);
            this.processWithNode(node, this.func);
            const result = this.currentMutation.test();
            result.filePath = filePath;
            (0, debug_1.default)("synvert-core:test")(result);
            return result;
        });
    }
    /**
     * Return matching files.
     * @returns {string[]} matching files
     */
    matchFilesInPathsSync() {
        const onlyPaths = configuration_1.default.onlyPaths.length > 0 ? configuration_1.default.onlyPaths : [""];
        return onlyPaths.flatMap((onlyPath) => this.matchFilesSync(onlyPath));
    }
    matchFilesInPaths() {
        return __awaiter(this, void 0, void 0, function* () {
            const onlyPaths = configuration_1.default.onlyPaths.length > 0 ? configuration_1.default.onlyPaths : [""];
            // It uses onlyPaths.flatMap((onlyPath) => this.matchFiles(onlyPath)) without async/await
            const [filePaths] = yield Promise.all(onlyPaths.map((onlyPath) => __awaiter(this, void 0, void 0, function* () { return yield this.matchFiles(onlyPath); })));
            return filePaths;
        });
    }
    matchFilesSync(onlyPath) {
        return fast_glob_1.default.sync(path_1.default.join(onlyPath, this.filePattern), {
            ignore: configuration_1.default.skipPaths,
            cwd: configuration_1.default.rootPath,
            onlyFiles: true,
            unique: true,
        });
    }
    matchFiles(onlyPath) {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, fast_glob_1.default)(path_1.default.join(onlyPath, this.filePattern), {
                ignore: configuration_1.default.skipPaths,
                cwd: configuration_1.default.rootPath,
                onlyFiles: true,
                unique: true,
            });
        });
    }
    /**
     * Parse code ast node.
     * @private
     * @param filePath {string} file path
     * @param source {string} file source
     * @returns {Node} ast node
     */
    parseCode(filePath, source) {
        if (this.rewriter.options.parser === options_1.Parser.TYPESCRIPT) {
            return this.parseByTypescript(filePath, source);
        }
        return this.parseByEspree(filePath, source);
    }
    /**
     * Parse by typescript.
     * @private
     * @param filePath {string} file path
     * @param source {string} file source
     * @returns {Node} ast node
     */
    parseByTypescript(filePath, source) {
        node_query_1.default.configure({ adapter: new node_query_1.TypescriptAdapter() });
        node_mutation_1.default.configure({ adapter: new node_mutation_1.TypescriptAdapter() });
        const scriptKind = ["js", "jsx"].includes(path_1.default.extname(filePath))
            ? typescript_1.default.ScriptKind.JSX
            : typescript_1.default.ScriptKind.TSX;
        return typescript_1.default.createSourceFile(filePath, source, typescript_1.default.ScriptTarget.Latest, true, scriptKind);
    }
    /**
     * Parse by espree.
     * @private
     * @param filePath {string} file path
     * @param source {string} file source
     * @returns {Node} ast node
     */
    parseByEspree(filePath, source) {
        node_query_1.default.configure({ adapter: new espree_adapter_2.default() });
        node_mutation_1.default.configure({ adapter: new espree_adapter_1.default() });
        return espree.parse(source, {
            ecmaVersion: "latest",
            loc: true,
            sourceType: this.rewriter.options.sourceType,
            sourceFile: filePath,
            ecmaFeatures: { jsx: true },
        });
    }
}
exports.default = Instance;
global.withinNode = Instance.prototype.withinNode;
global.withNode = Instance.prototype.withinNode;
global.findNode = Instance.prototype.withinNode;
global.gotoNode = Instance.prototype.gotoNode;
global.ifExistNode = Instance.prototype.ifExistNode;
global.unlessExistNode = Instance.prototype.unlessExistNode;
global.ifOnlyExistNode = Instance.prototype.ifOnlyExistNode;
global.ifAllNodes = Instance.prototype.ifAllNodes;
global.append = Instance.prototype.append;
global.prepend = Instance.prototype.prepend;
global.insert = Instance.prototype.insert;
global.insertAfter = Instance.prototype.insertAfter;
global.insertBefore = Instance.prototype.insertBefore;
global.deleteNode = Instance.prototype.delete;
global.remove = Instance.prototype.remove;
global.replace = Instance.prototype.replace;
global.replaceWith = Instance.prototype.replaceWith;
global.noop = Instance.prototype.noop;
global.callHelperSync = Instance.prototype.callHelperSync;
global.callHelper = Instance.prototype.callHelper;
global.mutationAdapter = Instance.prototype.mutationAdapter;
global.indent = utils_1.indent;
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.7</a> on Tue Dec 06 2022 13:55:46 GMT+0000 (Coordinated Universal Time) using the Minami theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
