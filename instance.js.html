<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>instance.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <li class="nav-link nav-home-link"><a href="index.html">Home</a></li><li class="nav-heading">Classes</li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="Array.html">Array</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Array.html#first">first</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Array.html#last">last</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Array.html#toSource">toSource</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="Condition.html">Condition</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Condition.html#process">process</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="Configuration.html">Configuration</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="GotoScope.html">GotoScope</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="GotoScope.html#process">process</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="IfAllCondition.html">IfAllCondition</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="IfAllCondition.html#process">process</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="IfExistCondition.html">IfExistCondition</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="IfExistCondition.html#match">match</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="IfExistCondition.html#process">process</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="IfOnlyExistCondition.html">IfOnlyExistCondition</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="IfOnlyExistCondition.html#match">match</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="IfOnlyExistCondition.html#process">process</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="Instance.html">Instance</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Instance.html#append">append</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Instance.html#delete">delete</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Instance.html#gotoNode">gotoNode</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Instance.html#ifAllNodes">ifAllNodes</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Instance.html#ifExistNode">ifExistNode</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Instance.html#ifOnlyExistNode">ifOnlyExistNode</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Instance.html#insert">insert</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Instance.html#matchFilesInPaths">matchFilesInPaths</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Instance.html#noop">noop</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Instance.html#prepend">prepend</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Instance.html#process">process</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Instance.html#processWithNode">processWithNode</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Instance.html#processWithOtherNode">processWithOtherNode</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Instance.html#remove">remove</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Instance.html#replace">replace</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Instance.html#replaceWith">replaceWith</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Instance.html#test">test</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Instance.html#unlessExistNode">unlessExistNode</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="Node.html">Node</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="NodeVersion.html">NodeVersion</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="NodeVersion.html#match">match</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="NpmVersion.html">NpmVersion</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="NpmVersion.html#match">match</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="QueryScope.html">QueryScope</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="QueryScope.html#process">process</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="Rewriter.html">Rewriter</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Rewriter.html#.clear">clear</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Rewriter.html#.fetch">fetch</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Rewriter.html#.register">register</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Rewriter.html#addFile">addFile</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Rewriter.html#addSnippet">addSnippet</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Rewriter.html#ifNode">ifNode</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Rewriter.html#ifNpm">ifNpm</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Rewriter.html#process">process</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Rewriter.html#processWithSandbox">processWithSandbox</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Rewriter.html#removeFile">removeFile</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Rewriter.html#test">test</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Rewriter.html#withinFile">withinFile</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Rewriter.html#withinFile">withinFile</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="Rewriter.html#withinFiles">withinFiles</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="Scope.html">Scope</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="UnlessExistCondition.html">UnlessExistCondition</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="UnlessExistCondition.html#match">match</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="UnlessExistCondition.html#process">process</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="WithinScope.html">WithinScope</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="WithinScope.html#process">process</a></span></li><li class="nav-heading">Externals</li><li class="nav-heading"><span class="nav-item-type type-external">E</span><span class="nav-item-name"><a href="external-Array.html">Array</a></span></li><li class="nav-heading"><span class="nav-item-type type-external">E</span><span class="nav-item-name"><a href="external-Node.html">Node</a></span></li><li class="nav-heading"><a href="global.html">Globals</a></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="global.html#indent">indent</a></span></li>
</nav>

<div id="main">
    
    <h1 class="page-title">instance.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>"use strict";
var __createBinding = (this &amp;&amp; this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this &amp;&amp; this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this &amp;&amp; this.__importStar) || function (mod) {
    if (mod &amp;&amp; mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" &amp;&amp; Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this &amp;&amp; this.__importDefault) || function (mod) {
    return (mod &amp;&amp; mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const typescript_1 = __importDefault(require("typescript"));
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const fast_glob_1 = __importDefault(require("fast-glob"));
const minimatch_1 = __importDefault(require("minimatch"));
const debug_1 = __importDefault(require("debug"));
const configuration_1 = __importDefault(require("./configuration"));
const scope_1 = require("./scope");
const condition_1 = require("./condition");
const utils_1 = require("./utils");
const node_query_1 = __importStar(require("@xinminlabs/node-query"));
const node_mutation_1 = __importStar(require("@xinminlabs/node-mutation"));
const espree_adapter_1 = __importDefault(require("./node-mutation/espree-adapter"));
const espree_adapter_2 = __importDefault(require("./node-query/espree-adapter"));
const options_1 = require("./types/options");
const espree = require("@xinminlabs/espree");
node_mutation_1.default.configure({ strategy: node_mutation_1.STRATEGY.KEEP_RUNNING });
/**
 * Instance is an execution unit, it finds specified ast nodes,
 * checks if the nodes match some conditions, then insert, replace or delete code.
 * One instance can contains one or many Scope and Condition.
 * @borrows Instance#withinNode as Instance#withNode
 */
class Instance {
    /**
     * Create an Instance
     * @param {string} filePattern - pattern to find files, e.g. `lib/*.js`
     * @param {Function} func - a function to find nodes, match conditions and rewrite code.
     */
    constructor(rewriter, filePattern, func) {
        this.rewriter = rewriter;
        this.filePattern = filePattern;
        this.func = func;
    }
    /**
     * Process the instance.
     * It finds all files, for each file, it runs the func, rewrites the original code,
     * then write the code back to the original file.
     */
    process() {
        if (fs_1.default.existsSync(configuration_1.default.rootPath) &amp;&amp;
            (0, minimatch_1.default)(configuration_1.default.rootPath, this.filePattern)) {
            return this.processFile(configuration_1.default.rootPath);
        }
        this.matchFilesInPaths().forEach((filePath) => this.processFile(filePath));
    }
    /**
     * Test the instance.
     * It finds all files, for each file, it runs the func, and gets the process results.
     * @returns {TestResultExt[]} test results
     */
    test() {
        if (fs_1.default.existsSync(configuration_1.default.rootPath) &amp;&amp;
            (0, minimatch_1.default)(configuration_1.default.rootPath, this.filePattern)) {
            return [this.testFile(configuration_1.default.rootPath)];
        }
        return this.matchFilesInPaths().map((filePath) => this.testFile(filePath));
    }
    /**
     * Set currentNode to node and process.
     * @param {Node} node - set to current node
     * @param {Function} func
     */
    processWithNode(node, func) {
        this.currentNode = node;
        func.call(this, this);
        this.currentNode = node;
    }
    /**
     * Set currentNode properly, process and set currentNode back to original currentNode.
     * @param {Node} node - set to other node
     * @param {Function} func
     */
    processWithOtherNode(node, func) {
        const originalNode = this.currentNode;
        this.currentNode = node;
        func.call(this, this);
        this.currentNode = originalNode;
    }
    findNode(nql, options, func) {
        if (typeof options === "function") {
            new scope_1.QueryScope(Instance.current, nql, {}, options).process();
        }
        else {
            new scope_1.QueryScope(Instance.current, nql, options, func).process();
        }
    }
    withinNode(rules, options, func) {
        if (typeof options === "function") {
            new scope_1.WithinScope(Instance.current, rules, {}, options).process();
        }
        else {
            new scope_1.WithinScope(Instance.current, rules, options, func).process();
        }
    }
    /**
     * Parse gotoNode dsl.
     * It creates a {@link GotoScope} to go to a child node,
     * then continue operating on the child node.
     * @example
     * // `$.ajax({ ... })` goes to `$.ajax`
     * gotoNode('callee')
     * @param {string} child_node_name - the name of the child nodes.
     * @param {Function} func - to continue operating on the matching nodes.
     */
    gotoNode(childNodeName, func) {
        new scope_1.GotoScope(Instance.current, childNodeName, func).process();
    }
    /**
     * Parse ifExistNode dsl
     * It creates a {@link IfExistCondition} to check if matching nodes exist in the child nodes,
     * if so, then continue operating on each matching ast node.
     * @example
     * // `class Foobar extends React.Component` matches and call `foobar`.
     * ifExistNode({ nodeType: "ClassDeclaration", superClass: { nodeType: "MemberExpression", object: "React", property: "Component" } }, () => { foobar })
     * @param {Object} rules - to check mathing ast nodes.
     * @param {Object} options - to do find in specific child node, e.g. { in: 'callee' }
     * @param {Function} func - to continue operating on the matching nodes.
     */
    ifExistNode(rules, options, func) {
        new condition_1.IfExistCondition(Instance.current, rules, options, func).process();
    }
    /**
     * Parse unlessExistNode dsl
     * It creates a {@link UnlessExistCondition} to check if matching nodes does not exist in the child nodes,
     * if so, then continue operating on each matching ast node.
     * @example
     * // `class Foobar extends Component` matches and call `foobar`.
     * unlessExistNode({ nodeType: "ClassDeclaration", superClass: { nodeType: "MemberExpression", object: "React", property: "Component" } }, () => {})
     * @param {Object} rules - to check mathing ast nodes.
     * @param {Object} options - to do find in specific child node, e.g. { in: 'callee' }
     * @param {Function} func - to continue operating on the matching nodes.
     */
    unlessExistNode(rules, options, func) {
        new condition_1.UnlessExistCondition(Instance.current, rules, options, func).process();
    }
    /**
     * Parse ifOnlyExistNode dsl
     * It creates a {@link IfOnlyExistCondition} to check if current node has only one child node and the child node matches rules,
     * if so, then continue operating on each matching ast node.
     * @example
     * // `class Foobar { foo() {} }` matches and call foobar, `class Foobar { foo() {}; bar() {}; }` does not match
     * ifOnlyExistNode({ nodeType: "MethodDefinition", key: "foo" }, () => { foobar })
     * @param {Object} rules - to check mathing ast nodes.
     * @param {Object} options - to do find in specific child node, e.g. { in: 'callee' }
     * @param {Function} func - to continue operating on the matching nodes.
     */
    ifOnlyExistNode(rules, options, func) {
        new condition_1.IfOnlyExistCondition(Instance.current, rules, options, func).process();
    }
    /**
     * Parse ifAllNodes dsl
     * It creates a {@link IfAllCondition} to check if all matching nodes match options.match,
     * if so, then call the func, else call the elseFunc.
     * @example
     * // `class Foobar { foo() {}; bar() {}; }` matches and call foobar
     * IfAllNode({ nodeType: "MethodDefinition" }, { match: { key: { in: ["foo", "bar"] } } }, () => { foo }, () => { bar });
     * @param {Object} rules - to check mathing ast nodes.
     * @param {Object} options - { match: rules, in: 'callee' }
     * @param {Function} func - to continue if all the matching nodes match options.match.
     * @param {Function} elseFunc - to continue if not all the matching nodes match options.match.
     */
    ifAllNodes(rules, options, func, elseFunc) {
        new condition_1.IfAllCondition(Instance.current, rules, options, func, elseFunc).process();
    }
    /**
     * Parse append dsl.
     * It creates a {@link AppendAction} to append the code to the bottom of current node body.
     * @example
     * // foo() => {}
     * // will be converted to
     * // foo() => {}
     * // bar() => {}
     * // after executing
     * withNode({ nodeType: "MethodDefinition", key: "foo" }, () => {
     *   append("bar() => {}")
     * })
     * @param {string} code - need to be appended.
     */
    append(code) {
        Instance.current.currentMutation.append(Instance.current.currentNode, code);
    }
    /**
     * Parse prepend dsl.
     * It creates a {@link PrependAction} to prepend the code to the top of current node body.
     * @example
     * // const foo = bar
     * // will be converted to
     * // 'use strict'
     * // const foo = bar
     * // after executing
     * prepend("'use strict'");
     * @param {string} code - need to be prepended.
     */
    prepend(code) {
        Instance.current.currentMutation.prepend(Instance.current.currentNode, code);
    }
    /**
     * Parse insert dsl.
     * It creates a {@link InsertAction} to replace child nodes with code.
     * @example
     * // import React, { Component } from 'react'
     * // will be converted to
     * // import React, { Component, useState } from 'react'
     * // after executing
     * withNode({ nodeType: "ImportSpecifier", local: "Component" }, () => {
     *   insert(", useState", { at: "end" });
     * });
     * @param {string} code - code need to be inserted
     * @param {Object} options - insert position, beginning or end, end is the default
     */
    insert(code, options) {
        Instance.current.currentMutation.insert(Instance.current.currentNode, code, options);
    }
    /**
     * Parse delete dsl.
     * It creates a {@link DeleteAction} to delete child nodes.
     * @example
     * // const someObject = { cat: cat, dog: dog, bird: bird }
     * // will be converted to
     * // const someObject = { cat, dog, bird }
     * // after executing
     * withNode({ nodeType: "Property", key: { nodeType: "Identifier" }, value: { nodeType: "Identifier" } }, () => {
     *   deleteNode(["semicolon", "value"]);
     * });
     * @param {string} selectors - name of child nodes
     */
    delete(selectors) {
        Instance.current.currentMutation.delete(Instance.current.currentNode, selectors);
    }
    /**
     * Parse remove dsl.
     * It creates a {@link RemoveAction} to remove current node.
     * @example
     * // class A {
     * //   constructor(props) {
     * //     super(props)
     * //   }
     * // }
     * // will be converted to
     * // class A {
     * // }
     * // after executing
     * withNode({ nodeType: "MethodDefinition", kind: "constructor" }, () => {
     *   remove();
     * });
     */
    remove() {
        Instance.current.currentMutation.remove(Instance.current.currentNode);
    }
    /**
     * Parse replace dsl.
     * It creates a {@link ReplaceAction} to replace child nodes with code.
     * @example
     * // $form.submit();
     * // will be converted to
     * // $form.trigger('submit');
     * // after executing
     * withNode({ nodeType: "CallExpression", callee: { nodeType: "MemberExpression", object: /^\$/, property: 'submit' }, arguments: { length: 0 } }, () => {
     *   replace(["callee.property", "arguments"], { with: "trigger('submit')" });
     * });
     * @param {string|array} selectors - name of child nodes.
     * @param {Object} options - code need to be replaced with.
     */
    replace(selectors, options) {
        Instance.current.currentMutation.replace(Instance.current.currentNode, selectors, options);
    }
    /**
     * Parse replaceWith dsl.
     * It creates a {@link ReplaceWithAction} to replace current node with code.
     * @example
     * // module.exports = Rewriter
     * // will be converted to
     * // export default Rewriter
     * // after executing
     * withNode({ nodeType: "ExpressionStatement", expression: { nodeType: "AssignmentExpression", left: { nodeType: "MemberExpression", object: "module", property: "exports" }, right: { nodeType: "Identifier" } } }, () => {
     *   replaceWith("export default {{expression.right}}");
     * });
     * @param {string} code - code need to be replaced.
     * @param {Object} options - { autoIndent: true } if auto fix indent
     */
    replaceWith(code, options) {
        Instance.current.currentMutation.replaceWith(Instance.current.currentNode, code, options);
    }
    /**
     * Parse noop dsl.
     */
    noop() {
        Instance.current.currentMutation.noop(Instance.current.currentNode);
    }
    /**
     * Process one file.
     * @private
     * @param {string} filePath - file path
     */
    processFile(filePath) {
        this.currentFilePath = path_1.default.join(configuration_1.default.rootPath, filePath);
        if (configuration_1.default.showRunProcess) {
            console.log(filePath);
        }
        while (true) {
            let source = fs_1.default.readFileSync(this.currentFilePath, "utf-8");
            this.currentFileSource = source;
            this.currentMutation = new node_mutation_1.default(source);
            try {
                const node = this.parseCode(this.currentFilePath, source);
                this.processWithNode(node, this.func);
                const result = this.currentMutation.process();
                (0, debug_1.default)("synvert-core:process")(result);
                if (result.affected) {
                    fs_1.default.writeFileSync(this.currentFilePath, result.newSource);
                }
                if (!result.conflicted) {
                    break;
                }
            }
            catch (e) {
                console.log(e);
                if (e instanceof SyntaxError) {
                    console.log(`May not parse source code: ${source}`);
                }
                break;
            }
        }
    }
    /**
     * Test one file.
     * @private
     * @param {string} filePath - file path
     * @returns {TestResultExt}
     */
    testFile(filePath) {
        this.currentFilePath = path_1.default.join(configuration_1.default.rootPath, filePath);
        let source = fs_1.default.readFileSync(this.currentFilePath, "utf-8");
        this.currentFileSource = source;
        this.currentMutation = new node_mutation_1.default(source);
        const node = this.parseCode(this.currentFilePath, source);
        this.processWithNode(node, this.func);
        const result = this.currentMutation.test();
        result.filePath = filePath;
        (0, debug_1.default)("synvert-core:test")(result);
        return result;
    }
    /**
     * Return matching files.
     * @returns {string[]} matching files
     */
    matchFilesInPaths() {
        const onlyPaths = configuration_1.default.onlyPaths.length > 0 ? configuration_1.default.onlyPaths : [""];
        return onlyPaths.flatMap((onlyPath) => this.matchFiles(onlyPath));
    }
    matchFiles(onlyPath) {
        return fast_glob_1.default.sync(path_1.default.join(onlyPath, this.filePattern), {
            ignore: configuration_1.default.skipPaths,
            cwd: configuration_1.default.rootPath,
            onlyFiles: true,
            unique: true,
        });
    }
    /**
     * Parse code ast node.
     * @private
     * @param filePath {string} file path
     * @param source {string} file source
     * @returns {Node} ast node
     */
    parseCode(filePath, source) {
        if (this.rewriter.options.parser === options_1.Parser.Typescript) {
            return this.parseByTypescript(filePath, source);
        }
        return this.parseByEspree(filePath, source);
    }
    /**
     * Parse by typescript.
     * @private
     * @param filePath {string} file path
     * @param source {string} file source
     * @returns {Node} ast node
     */
    parseByTypescript(filePath, source) {
        node_query_1.default.configure({ adapter: new node_query_1.TypescriptAdapter() });
        node_mutation_1.default.configure({ adapter: new node_mutation_1.TypescriptAdapter() });
        const scriptKind = ["js", "jsx"].includes(path_1.default.extname(filePath))
            ? typescript_1.default.ScriptKind.JSX
            : typescript_1.default.ScriptKind.TSX;
        return typescript_1.default.createSourceFile(filePath, source, typescript_1.default.ScriptTarget.Latest, true, scriptKind);
    }
    /**
     * Parse by espree.
     * @private
     * @param filePath {string} file path
     * @param source {string} file source
     * @returns {Node} ast node
     */
    parseByEspree(filePath, source) {
        node_query_1.default.configure({ adapter: new espree_adapter_2.default() });
        node_mutation_1.default.configure({ adapter: new espree_adapter_1.default() });
        return espree.parse(source, {
            ecmaVersion: "latest",
            loc: true,
            sourceType: this.rewriter.options.sourceType,
            sourceFile: filePath,
            ecmaFeatures: { jsx: true },
        });
    }
}
exports.default = Instance;
global.findNode = Instance.prototype.findNode;
global.withinNode = Instance.prototype.withinNode;
global.withNode = Instance.prototype.withinNode;
global.gotoNode = Instance.prototype.gotoNode;
global.ifExistNode = Instance.prototype.ifExistNode;
global.unlessExistNode = Instance.prototype.unlessExistNode;
global.ifOnlyExistNode = Instance.prototype.ifOnlyExistNode;
global.ifAllNodes = Instance.prototype.ifAllNodes;
global.append = Instance.prototype.append;
global.prepend = Instance.prototype.prepend;
global.insert = Instance.prototype.insert;
global.deleteNode = Instance.prototype.delete;
global.remove = Instance.prototype.remove;
global.replace = Instance.prototype.replace;
global.replaceWith = Instance.prototype.replaceWith;
global.noop = Instance.prototype.noop;
global.indent = utils_1.indent;
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.7</a> on Wed Oct 12 2022 13:59:18 GMT+0000 (Coordinated Universal Time) using the Minami theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
